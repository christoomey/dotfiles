#!/usr/bin/env ruby
# Usage: git publish <remote-branch-name>
# Open the pull request page for <branch>, or the current branch if not
# specified. Lands on the new pull request page when no PR exists yet.
# The local branch must be tracking the remote branch.
#

GitCall = Struct.new(:cmd, :type, :pretend_resp)

class ClosesPullRequests
  def initialize(arg)
    @pretending = pretend? arg
  end

  def run
    capture_current_branch
    confirm_upstream_tracking_branch
    ensure_working_dir_and_index_clean
    checkout_master
    ensure_master_up_to_date
    merge_local_banch
    push_master
    delete_remote_branch
    delete_local_branch
  end

  private

  def die_with_msg(msg)
    puts msg
    exit 1
  end

  def capture_current_branch
    puts 'Capturing current branch name...'
    current_branch_cmd = 'git rev-parse --abbrev-ref HEAD'
    gc = GitCall.new(current_branch_cmd, :query, 'my-feature-branch')
    @current_branch = run_or_print(gc)
  end

  def confirm_upstream_tracking_branch
    puts 'Confirming upstream tracking branch configured...'
    confirm_cmd = "git config branch.#{@current_branch}.remote"
    gc = GitCall.new(confirm_cmd, :command, true)
    if run_or_print(gc)
      upstream_branch_cmd = 'git rev-parse --abbrev-ref --symbolic-full-name @{u}'
      gc = GitCall.new(upstream_branch_cmd, :query, 'upstream-feature-branch')
      @upstream_branch = run_or_print(gc).gsub('origin/', '')
    else
      die_with_msg 'no upstream branch configured. Aborting'
    end
  end

  def ensure_working_dir_and_index_clean
    puts 'Ensuring that index and working directory are clean...'
    index_clean_cmd = 'git diff --cached --exit-code > /dev/null 2>&1'
    index_gc = GitCall.new(index_clean_cmd, :command, true)
    working_dir_clean_cmd = 'git diff --exit-code > /dev/null 2>&1'
    working_dir_gc = GitCall.new(working_dir_clean_cmd, :command, true)
    unless run_or_print(index_gc) && run_or_print(working_dir_gc)
      die_with_msg 'Index or working dir not clean. Aborting.'
    end
  end

  def checkout_master
    puts 'Checking out master...'
    gc = GitCall.new('git checkout master', :command, true)
    run_or_print(gc)
  end

  def ensure_master_up_to_date
    puts 'Ensuring master branch is up to date...'
    current_sha_cmd = 'git-rev-parse --verify HEAD'
    old_head = run_or_print(GitCall.new(current_sha_cmd, :query, 'abcdef12'))
    run_or_print(GitCall.new('git pull', :command, true))
    new_head = run_or_print(GitCall.new(current_sha_cmd, :query, 'abcdef12'))
    unless old_head == new_head
      die_with_msg 'Master was out of date; rebase needed. Aborting'
    end
  end

  def merge_local_banch
    puts 'Merging branch into master...'
    merge_cmd = "git merge --ff-only #{@current_branch}"
    gc = GitCall.new(merge_cmd, :command, true)
    unless run_or_print(gc)
      die_with_msg "Branch '#{@current_branch}' is not fast-forwardable"
    end
  end

  def push_master
    puts 'Pushing updated master branch...'
    gc = GitCall.new('git push origin master', :command, true)
    run_or_print(gc)
  end

  def delete_remote_branch
    puts 'Deleting remote branch...'
    gc = GitCall.new("git push origin :#{@upstream_branch}", :command, true)
    run_or_print(gc)
  end

  def delete_local_branch
    puts 'Deleting local branch...'
    gc = GitCall.new("git branch -d #{@current_branch}", :command, true)
    run_or_print(gc)
  end

  def pretend?(arg)
    true if ['-p', '--pretend'].include? arg
  end

  def run_or_print(gc)
    puts "  ->  #{gc.cmd}"
    sleep 0.3
    if @pretending
      gc.pretend_resp
    else
      if gc.type == :command
        system(gc.cmd)
      else
        `#{gc.cmd}`.chomp
      end
    end
  end
end

ClosesPullRequests.new(ARGV.first).run
